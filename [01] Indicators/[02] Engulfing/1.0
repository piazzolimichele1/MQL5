#property strict
#property copyright "Michele Piazzoli"
#property version   "1.0"
#property description "Engulfing Pattern Detector"
#property description "Bullish: bullish candle closes above the high of the previous bearish candle"
#property description "Bearish: bearish candle closes below the low of the previous bullish candle"
#property description "Optional SMA filter with selectable timeframe"
#property indicator_chart_window
#property indicator_buffers 1
#property indicator_plots   1

#property indicator_label1  "SMA Filter"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrGold
#property indicator_style1  STYLE_DOT
#property indicator_width1  1

//══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//  INPUT PARAMETERS
//══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

// ── Visual ──
input int               InpArrowSize        = 2;               // Arrow Size
input int               InpArrowOffset      = 10;              // Arrow Offset from High/Low (points)
input color             InpBullColor        = clrLime;         // Bullish Engulfing Color
input color             InpBearColor        = clrRed;          // Bearish Engulfing Color

// ── SMA Filter ──
input bool              InpSMAFilter        = false;           // SMA Filter (true/false)
input int               InpSMAPeriod        = 200;             // SMA Period
input ENUM_TIMEFRAMES   InpSMATimeframe     = PERIOD_CURRENT;  // SMA Timeframe
input color             InpSMAColor         = clrGold;         // SMA Line Color

//══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//  GLOBAL VARIABLES
//══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

int    g_handleSMA = INVALID_HANDLE;
double g_smaBuffer[];

//══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//  INIT / DEINIT
//══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

int OnInit()
{
   SetIndexBuffer(0, g_smaBuffer, INDICATOR_DATA);
   ArraySetAsSeries(g_smaBuffer, true);

   if(InpSMAFilter)
   {
      ENUM_TIMEFRAMES tf = (InpSMATimeframe == PERIOD_CURRENT) ? _Period : InpSMATimeframe;
      g_handleSMA = iMA(_Symbol, tf, InpSMAPeriod, 0, MODE_SMA, PRICE_CLOSE);
      if(g_handleSMA == INVALID_HANDLE)
         Print("[WARNING] Failed to create SMA handle");

      PlotIndexSetInteger(0, PLOT_DRAW_TYPE, DRAW_LINE);
      PlotIndexSetInteger(0, PLOT_LINE_COLOR, InpSMAColor);
      PlotIndexSetString(0, PLOT_LABEL, "SMA " + IntegerToString(InpSMAPeriod));
   }
   else
   {
      PlotIndexSetInteger(0, PLOT_DRAW_TYPE, DRAW_NONE);
   }

   return INIT_SUCCEEDED;
}

void OnDeinit(const int reason)
{
   if(g_handleSMA != INVALID_HANDLE)
      IndicatorRelease(g_handleSMA);

   int total = ObjectsTotal(0);
   for(int i = total - 1; i >= 0; i--)
   {
      string name = ObjectName(0, i);
      if(StringFind(name, "MP_ENG_") >= 0)
         ObjectDelete(0, name);
   }
}

//══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════
//  ON CALCULATE
//══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════

int OnCalculate(const int rates_total, const int prev_calculated,
                const datetime &time[], const double &open[], const double &high[],
                const double &low[], const double &close[],
                const long &tick_volume[], const long &volume[], const int &spread[])
{
   if(rates_total < 3) return rates_total;

   ArraySetAsSeries(time, true);
   ArraySetAsSeries(open, true);
   ArraySetAsSeries(high, true);
   ArraySetAsSeries(low, true);
   ArraySetAsSeries(close, true);

   int start, end;

   if(prev_calculated == 0)
   {
      start = 1;
      end   = rates_total - 2;
   }
   else
   {
      start = 1;
      end   = 1;
   }

   double offset = InpArrowOffset * _Point;

   // Fill SMA buffer if filter is active
   if(InpSMAFilter && g_handleSMA != INVALID_HANDLE)
   {
      ENUM_TIMEFRAMES smaTF = (InpSMATimeframe == PERIOD_CURRENT) ? _Period : InpSMATimeframe;

      if(smaTF == _Period)
      {
         // Same TF: copy directly
         CopyBuffer(g_handleSMA, 0, 0, rates_total, g_smaBuffer);
      }
      else
      {
         // Higher TF: map each chart bar to the corresponding SMA value
         for(int b = 0; b < rates_total; b++)
         {
            int htfBar = iBarShift(_Symbol, smaTF, time[b]);
            double sma[1];
            if(CopyBuffer(g_handleSMA, 0, htfBar, 1, sma) == 1)
               g_smaBuffer[b] = sma[0];
            else
               g_smaBuffer[b] = EMPTY_VALUE;
         }
      }
   }
   else
   {
      // No filter: empty buffer
      ArrayInitialize(g_smaBuffer, EMPTY_VALUE);
   }

   for(int i = start; i <= end; i++)
   {
      double o1 = open[i],  h1 = high[i],  l1 = low[i],  c1 = close[i];
      double o2 = open[i+1], h2 = high[i+1], l2 = low[i+1], c2 = close[i+1];

      bool bull1 = c1 > o1;
      bool bear1 = c1 < o1;
      bool bull2 = c2 > o2;
      bool bear2 = c2 < o2;

      string name = "MP_ENG_" + IntegerToString((long)time[i]);

      // ── Bullish Engulfing: only above SMA ──
      if(bear2 && bull1 && c1 > h2)
      {
         bool allowed = true;
         if(InpSMAFilter && g_smaBuffer[i] != EMPTY_VALUE && c1 <= g_smaBuffer[i])
            allowed = false;

         if(allowed && ObjectFind(0, name) < 0)
         {
            ObjectCreate(0, name, OBJ_ARROW, 0, time[i], l1 - offset);
            ObjectSetInteger(0, name, OBJPROP_ARROWCODE, 233);
            ObjectSetInteger(0, name, OBJPROP_COLOR, InpBullColor);
            ObjectSetInteger(0, name, OBJPROP_WIDTH, InpArrowSize);
            ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
            ObjectSetInteger(0, name, OBJPROP_BACK, false);
         }
      }

      // ── Bearish Engulfing: only below SMA ──
      if(bull2 && bear1 && c1 < l2)
      {
         bool allowed = true;
         if(InpSMAFilter && g_smaBuffer[i] != EMPTY_VALUE && c1 >= g_smaBuffer[i])
            allowed = false;

         if(allowed && ObjectFind(0, name) < 0)
         {
            ObjectCreate(0, name, OBJ_ARROW, 0, time[i], h1 + offset);
            ObjectSetInteger(0, name, OBJPROP_ARROWCODE, 234);
            ObjectSetInteger(0, name, OBJPROP_COLOR, InpBearColor);
            ObjectSetInteger(0, name, OBJPROP_WIDTH, InpArrowSize);
            ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
            ObjectSetInteger(0, name, OBJPROP_BACK, false);
         }
      }
   }

   return rates_total;
}
